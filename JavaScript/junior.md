```markdown
# 1. Какие типы данных существуют в JavaScript?

В JavaScript есть примитивные типы и объекты. Примитивы — это простые 
значения: числа, строки, булевы значения, null и undefined. Объекты — это 
сложные структуры, которые могут хранить наборы данных и функции.

Дополнительно: понимание типов данных помогает правильно работать с 
информацией и избежать ошибок при обработке.

```js
console.log("Example 1");
let number = 10;               // Number — числовое значение
let text = "Hello";            // String — строка текста
let flag = true;               // Boolean — логическое значение (true или false)
let nothing = null;            // Null — специальное значение, означающее «пусто»
let notDefined;                // Undefined — значение по умолчанию для
                               // неинициализированных переменных
let obj = { key: "value" };    // Object — коллекция ключей и значений

// Output 1: 10 Hello true null undefined { key: 'value' }
console.log("Output 1:", number, text, flag, nothing, notDefined, obj);
```

# 2. Чем отличаются var, let и const?

var — объявляет переменную с функцией или глобальной областью видимости, что 
может приводить к ошибкам. let — блочная область видимости, улучшенная замена 
var. const — объявляет константу, значение которой нельзя изменить после присвоения.

Дополнительно: использовать let и const предпочтительнее для более 
предсказуемого поведения кода.

```js
console.log("\nExample 2");
var a = 1;
let b = 2;
const c = 3;
b = 10;                       // Можно менять let, нельзя менять const
console.log("Output 2:", a, b, c); // Output 2: 1 10 3

// Ошибка при попытке изменить const:
// c = 5; // Uncaught TypeError: Assignment to constant variable.
// Причина: const создаёт константу, попытка изменить значение запрещена и вызывает ошибку.
```

# 3. Что такое функция и как её объявить?

Функция — блок кода, который выполняет задачу и может принимать входные данные 
(параметры) и возвращать результат. Позволяет повторно использовать код.

Дополнительно: функции помогают структурировать код и делают программу более 
понятной и удобной для поддержки.

```js
console.log("\nExample 3");
function greet(name) {
  return `Hello, ${name}!`;   // Используем шаблонные строки для удобного форматирования
}
console.log("Output 3:", greet("Alice")); // Output 3: Hello, Alice!
```

# 4. Что такое callback-функция?

Callback — функция, переданная в другую функцию для вызова позже. Часто 
используется для обработки асинхронных действий, например, после получения данных.

Дополнительно: callbacks позволяют строить цепочки действий, когда одно зависит 
от результата другого.

```js
console.log("\nExample 4");
function ask(question, callback) {
  console.log("Output 4:", question);  // Output 4: How are you?
  callback();                 // Вызываем переданную функцию
}
ask("How are you?", () => {
  console.log("Output 4:", "I'm fine, thanks!"); // Output 4: I'm fine, thanks!
});
```

# 5. В чём разница между операторами == и ===?

== сравнивает значения с приведением типов (например, число и строку), что может 
привести к неожиданным результатам. === — строгое сравнение без приведения типов.

Дополнительно: рекомендуется всегда использовать === для точного сравнения.

```js
console.log("\nExample 5");
console.log("Output 5 (==):", 5 == "5");   // Output 5 (==): true
console.log("Output 5 (===):", 5 === "5"); // Output 5 (===): false
```

# 6. Что такое замыкание (closure)?

Замыкание — функция, которая «запоминает» окружение, в котором была создана, 
позволяя обращаться к переменным этого окружения даже после выхода из него.

Дополнительно: замыкания широко используются для создания приватных данных и функций.

```js
console.log("\nExample 6");
function createCounter() {
  let count = 0;              // Переменная count доступна только внутри createCounter
  return function() {
    count++;                  // Внутренняя функция может изменять и использовать count
    return count;
  };
}
const counter = createCounter();
console.log("Output 6 (call 1):", counter()); // Output 6 (call 1): 1
console.log("Output 6 (call 2):", counter()); // Output 6 (call 2): 2
```

# 7. Что такое Promise?

Promise — объект для работы с асинхронным кодом. Позволяет запускать действия, которые 
завершатся успехом или ошибкой, и обрабатывать эти результаты.

Дополнительно: Promises делают код с асинхронностью чище и понятнее.

```js
console.log("\nExample 7");
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Done!"), 1000);  // Через 1 секунду вызываем resolve
});
promise.then(result => console.log("Output 7:", result)); // Output 7: Done!
```

# 8. Как работает ключевое слово this?

this — ссылка на текущий объект, в контексте которого выполняется функция. Значение зависит 
от способа вызова функции.

Дополнительно: понимание this важно для правильного доступа к данным объекта.

```js
console.log("\nExample 8");
const person = {
  name: "John",
  greet() {
    console.log("Output 8:", this.name);  // Output 8: John; this ссылается на объект person
  }
};
person.greet();
```

# 9. Что такое всплытие (bubbling) и погружение (capturing) событий?

События в DOM могут сначала «погружаться» сверху вниз (capturing), затем срабатывать 
на целевом элементе и «всплывать» обратно вверх (bubbling). Позволяет контролировать, 
как обрабатывать события.

Дополнительно: важно для настройки правильного порядка обработки событий.

```js
console.log("\nExample 9");
// (Вывод зависит от событий браузера, здесь пример для теории)
```

# 10. Что такое стрелочные функции?

Краткий синтаксис объявления функций, который автоматически связывает значение this с 
внешним контекстом, что удобно для обратных вызовов.

Дополнительно: стрелочные функции не имеют собственного this, что предотвращает ошибки 
при передаче функций.

```js
console.log("\nExample 10");
const add = (x, y) => x + y;
console.log("Output 10:", add(2, 3)); // Output 10: 5
```

# 11. В чём разница между null и undefined?

undefined — переменная объявлена, но не инициализирована (нет значения). null — специальное 
значение, которое обозначает отсутствие какого-либо значения.

Дополнительно: null обычно задаётся программистом, undefined — автоматически.

```js
console.log("\nExample 11");
let undefinedVar;
let nullVar = null;
console.log("Output 11 (undefined):", undefinedVar); // Output 11 (undefined): undefined
console.log("Output 11 (null):", nullVar);           // Output 11 (null): null
```

# 12. Как создать объект?

Объекты — это структуры, которые могут хранить данные (свойства) и функции (методы). Используются 
для группировки логически связанных данных.

Дополнительно: объекты позволяют моделировать реальные сущности в программе.

```js
console.log("\nExample 12");
const user = {
  name: "Alice",
  age: 25
};
console.log("Output 12 (name):", user.name); // Output 12 (name): Alice
console.log("Output 12 (age):", user.age);   // Output 12 (age): 25
```

# 13. Чем отличаются синхронный и асинхронный код?

Синхронный код выполняется построчно, блокируя программу, пока не завершится. Асинхронный — 
позволяет выполнять задачи параллельно, не блокируя основное выполнение.

Дополнительно: асинхронность важна для работы с сетью и файлами.

```js
console.log("\nExample 13");
// (вывод зависит от кода, здесь теоретическое объяснение)
```

# 14. Что делает метод массива map()?

map() создаёт новый массив, применяя указанную функцию к каждому элементу исходного массива, 
не изменяя оригинал.

Дополнительно: map позволяет легко трансформировать данные в массиве.

```js
console.log("\nExample 14");
const arr = [1, 2, 3];
const doubled = arr.map(x => x * 2);
console.log("Output 14:", doubled); // Output 14: [2, 4, 6]
```

# 15. Что такое модули?

Модули позволяют разделять код на отдельные файлы и использовать экспорт и импорт для 
повторного использования функций, объектов и данных.

Дополнительно: модули делают код более структурированным и читаемым.

```js
console.log("\nExample 15");
// (вывод зависит от реализации модулей, здесь теоретическое объяснение)
```

# 16. Чем отличается forEach от map?

forEach выполняет функцию для каждого элемента, не возвращая результат. map возвращает новый 
массив с результатами вызова функции.

Дополнительно: forEach используется для действий, map — для преобразования.

```js
console.log("\nExample 16");
// (вывод зависит от кода, здесь теоретическое объяснение)
```

# 17. Что такое prototype?

Prototype — это объект, от которого наследуются свойства и методы. Позволяет реализовать 
наследование в JavaScript.

Дополнительно: понимание prototype важно для работы с объектно-ориентированным 
программированием в JS.

```js
console.log("\nExample 17");
// (вывод зависит от примера наследования, здесь теоретическое объяснение)
```

# 18. Как обрабатывать ошибки?

Для перехвата ошибок используется конструкция try…catch, что позволяет программе продолжать 
работу после возникновения исключения.

Дополнительно: обработка ошибок повышает надежность и устойчивость кода.

```js
console.log("\nExample 18");
try {
  throw new Error("Error!");
} catch (error) {
  console.log("Output 18:", error.message); // Output 18: Error!
}

// Ошибка: если не использовать try…catch, программа остановится при ошибке.
// Например:
// throw new Error("Stop!"); // Программа завершится с ошибкой.
```

# 19. Чем отличается область видимости let и var?

let имеет блочную область видимости (ограничена фигурными скобками), var — функциональную 
или глобальную. Это важно для предотвращения ошибок.

Дополнительно: использование let помогает избегать конфликтов переменных.

```js
console.log("\nExample 19");
if (true) {
  let x = 1;
  var y = 2;
}
// console.log(x); // Ошибка: x не доступна вне блока if
console.log("Output 19 (typeof x):", typeof x); // Output 19 (typeof x): undefined,
                                                // т.к. x вне блока 
console.log("Output 19 (y):", y);               // Output 19 (y): 2
```

# 20. Что такое hoisting?

Hoisting — механизм, при котором объявления переменных и функций «поднимаются» вверх 
области видимости, что позволяет использовать их до явного объявления.

Переменные var «поднимаются» и инициализируются значением undefined. Переменные let и 
const тоже поднимаются, но в «временную мёртвую зону» — их нельзя использовать до 
объявления, иначе будет ошибка ReferenceError.

Дополнительно: в примере мы вызываем переменную a до её объявления, что работает из-за 
hoisting, но значение будет undefined до присвоения.

```js
console.log("\nExample 20");
console.log("Output 20 (before declaration):", a); // Output 20 (before declaration): undefined
var a = 5;

// Ошибка при использовании let до объявления:
// console.log(b); // ReferenceError: Cannot access 'b' before initialization
// let b = 10;
// Причина: let и const находятся в «временной мёртвой зоне» (TDZ), из-за чего
// обращение к ним до объявления вызывает ReferenceError.

// Аналогично, функция, объявленная через function declaration, поднимается и может
// быть вызвана до объявления, а функция через function expression или стрелочная
// — нет.
```
